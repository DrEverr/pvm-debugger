/* eslint-disable no-useless-escape */

export const instructionsToLatex = {
  "": "",
  TRAP: "trap",
  FALLTHROUGH: "Continues execution to the next instruction",
  ECALLI: "System call interface",
  STORE_IMM_U8: "\\mu[\\omega_A] = \\nu_X \\mod 2^8",
  STORE_IMM_U16: "\\mu[\\omega_A] = \\nu_X \\mod 2^{16}",
  STORE_IMM_U32: "\\mu[\\omega_A] = \\nu_X \\mod 2^{32}",
  JUMP: "\\iota = \\omega_A",
  JUMP_IND: "\\iota = \\mu[\\omega_A]",
  LOAD_IMM: "\\omega'_A = \\nu_X",
  LOAD_U8: "\\omega'_A = \\mu[\\omega_B] \\mod 2^8",
  LOAD_I8: "\\omega'_A = (\\mu[\\omega_B] \\mod 2^8) \\text{ as signed}",
  LOAD_U16: "\\omega'_A = \\mu[\\omega_B] \\mod 2^{16}",
  LOAD_I16: "\\omega'_A = (\\mu[\\omega_B] \\mod 2^{16}) \\text{ as signed}",
  LOAD_U32: "\\omega'_A = \\mu[\\omega_B] \\mod 2^{32}",
  STORE_U8: "\\mu[\\omega_A] = \\omega_B \\mod 2^8",
  STORE_U16: "\\mu[\\omega_A] = \\omega_B \\mod 2^{16}",
  STORE_U32: "\\mu[\\omega_A] = \\omega_B \\mod 2^{32}",
  STORE_IMM_IND_U8: "\\mu[\\mu[\\omega_A]] = \\nu_X \\mod 2^8",
  STORE_IMM_IND_U16: "\\mu[\\mu[\\omega_A]] = \\nu_X \\mod 2^{16}",
  STORE_IMM_IND_U32: "\\mu[\\mu[\\omega_A]] = \\nu_X \\mod 2^{32}",
  LOAD_IMM_JUMP: "\\omega'_A = \\nu_X; \\iota = \\nu_Y",
  BRANCH_EQ_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B = \\nu_X",
  BRANCH_NE_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B \\neq \\nu_X",
  BRANCH_LT_U_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B < \\nu_X",
  BRANCH_LE_U_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B \\leq \\nu_X",
  BRANCH_GE_U_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B \\geq \\nu_X",
  BRANCH_GT_U_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B > \\nu_X",
  BRANCH_LT_S_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B < \\nu_X \\text{ (signed)}",
  BRANCH_LE_S_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B \\leq \\nu_X \\text{ (signed)}",
  BRANCH_GE_S_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B \\geq \\nu_X \\text{ (signed)}",
  BRANCH_GT_S_IMM: "\\iota = \\omega_A \\text{ if } \\omega_B > \\nu_X \\text{ (signed)}",
  MOVE_REG: "\\omega'_A = \\omega_B",
  SBRK: "Increase program break (memory allocation)",
  STORE_IND_U8: "\\mu[\\mu[\\omega_A]] = \\omega_B \\mod 2^8",
  STORE_IND_U16: "\\mu[\\mu[\\omega_A]] = \\omega_B \\mod 2^{16}",
  STORE_IND_U32: "\\mu[\\mu[\\omega_A]] = \\omega_B \\mod 2^{32}",
  LOAD_IND_U8: "\\omega'_A = \\mu[\\mu[\\omega_B]] \\mod 2^8",
  LOAD_IND_I8: "\\omega'_A = (\\mu[\\mu[\\omega_B]] \\mod 2^8) \\text{ as signed}",
  LOAD_IND_U16: "\\omega'_A = \\mu[\\mu[\\omega_B]] \\mod 2^{16}",
  LOAD_IND_I16: "\\omega'_A = (\\mu[\\mu[\\omega_B]] \\mod 2^{16}) \\text{ as signed}",
  LOAD_IND_U32: "\\omega'_A = \\mu[\\mu[\\omega_B]] \\mod 2^{32}",
  ADD_IMM: "\\omega'_A = (\\omega_B + \\nu_X) \\mod 2^{32}",
  AND_IMM: "\\omega'_A = \\omega_B \\land \\nu_X",
  XOR_IMM: "\\omega'_A = \\omega_B \\oplus \\nu_X",
  OR_IMM: "\\omega'_A = \\omega_B \\lor \\nu_X",
  MUL_IMM: "\\omega'_A = (\\omega_B \\times \\nu_X) \\mod 2^{32}",
  MUL_UPPER_S_S_IMM: "\\omega'_A = ((\\omega_B \\times \\nu_X) \\gg 32) \\mod 2^{32}$ \\text{ (signed)}",
  MUL_UPPER_U_U_IMM: "\\omega'_A = ((\\omega_B \\times \\nu_X) \\gg 32) \\mod 2^{32}$ \\text{ (unsigned)}",
  SET_LT_U_IMM: "\\omega'_A = (\\omega_B < \\nu_X)",
  SET_LT_S_IMM: "\\omega'_A = (\\omega_B < \\nu_X) \\text{ (signed)}",
  SHLO_L_IMM: "\\omega'_A = \\omega_B \\ll \\nu_X",
  SHLO_R_IMM: "\\omega'_A = \\omega_B \\gg \\nu_X",
  SHAR_R_IMM: "\\omega'_A = \\omega_B \\gg \\nu_X \\text{ (signed)}",
  NEG_ADD_IMM: "\\omega'_A = -\\omega_B + \\nu_X",
  SET_GT_U_IMM: "\\omega'_A = (\\omega_B > \\nu_X)",
  SET_GT_S_IMM: "\\omega'_A = (\\omega_B > \\nu_X) \\text{ (signed)}",
  SHLO_L_IMM_ALT: "\\omega'_A = \\omega_B \\ll \\nu_X",
  SHLO_R_IMM_ALT: "\\omega'_A = \\omega_B \\gg \\nu_X",
  SHAR_R_IMM_ALT: "\\omega'_A = \\omega_B \\gg \\nu_X \\text{ (signed)}",
  CMOV_IZ_IMM: "\\omega'_A = \\nu_X \\text{ if } \\omega_B = 0",
  CMOV_NZ_IMM: "\\omega'_A = \\nu_X \\text{ if } \\omega_B \\neq 0",
  BRANCH_EQ: "\\iota = \\omega_A \\text{ if } \\omega_B = \\omega_C",
  BRANCH_NE: "\\iota = \\omega_A \\text{ if } \\omega_B \\neq \\omega_C",
  BRANCH_LT_U: "\\iota = \\omega_A \\text{ if } \\omega_B < \\omega_C",
  BRANCH_LT_S: "\\iota = \\omega_A \\text{ if } \\omega_B < \\omega_C \\text{ (signed)}",
  BRANCH_GE_U: "\\iota = \\omega_A \\text{ if } \\omega_B \\geq \\omega_C",
  BRANCH_GE_S: "\\iota = \\omega_A \\text{ if } \\omega_B \\geq \\omega_C \\text{ (signed)}",
  LOAD_IMM_JUMP_IND: "\\omega'_A = \\nu_X; \\iota = \\mu[\\omega_B]",
  ADD: "\\omega'_D = (\\omega_A + \\omega_B) \\mod 2^{32}",
  SUB: "\\omega'_D = (\\omega_A - \\omega_B) \\mod 2^{32}",
  AND: "\\omega'_D = \\omega_A \\land \\omega_B",
  XOR: "\\omega'_D = \\omega_A \\oplus \\omega_B",
  OR: "\\omega'_D = \\omega_A \\lor \\omega_B",
  MUL: "\\omega'_D = (\\omega_A \\times \\omega_B) \\mod 2^{32}",
  MUL_UPPER_S_S: "\\omega'_D = \\left(\\frac{\\omega_A \\times \\omega_B}{2^{32}}\\right) \\text{ (signed)}",
  MUL_UPPER_U_U: "\\omega'_D = \\left(\\frac{\\omega_A \\times \\omega_B}{2^{32}}\\right) \\text{ (unsigned)}",
  MUL_UPPER_S_U: "\\omega'_D = \\left(\\frac{\\omega_A \\times \\omega_B}{2^{32}}\\right) \\text{ (signed/unsigned)}",
  DIV_U: "\\omega'_D = \\left\\lfloor \\frac{\\omega_A}{\\omega_B} \\right\\rfloor \\text{ (unsigned)}",
  DIV_S: "\\omega'_D = \\left\\lfloor \\frac{\\omega_A}{\\omega_B} \\right\\rfloor \\text{ (signed)}",
  REM_U: "\\omega'_D = \\omega_A \\mod \\omega_B \\text{ (unsigned)}",
  REM_S: "\\omega'_D = \\omega_A \\mod \\omega_B \\text{ (signed)}",
  SET_LT_U: "\\omega'_A = (\\omega_B < \\omega_C) \\text{ (unsigned)}",
  SET_LT_S: "\\omega'_A = (\\omega_B < \\omega_C) \\text{ (signed)}",
  SHLO_L: "\\omega'_D = \\omega_A \\ll \\omega_B",
  SHLO_R: "\\omega'_D = \\omega_A \\gg \\omega_B",
  SHAR_R: "\\omega'_D = \\omega_A \\gg \\omega_B \\text{ (arithmetic)}",
  CMOV_IZ: "\\omega'_A = (\\omega_B \\text{ if } \\omega_C == 0 \\text{ else } \\omega_A)",
  CMOV_NZ: "\\omega'_A = (\\omega_B \\text{ if } \\omega_C \\neq 0 \\text{ else } \\omega_A)",
};
